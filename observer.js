// Generated by CoffeeScript 1.3.3

/*
dry-observer
v0.2.1

LICENSE: http://github.com/arbales/dry-observer/raw/master/LICENSE
*/


(function() {
  var InvalidBindingError, Observers, capitalize, createListener, deprecatedBackbone, destroyListener, eventSplitter, exports, root, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  root = this;

  _ = root._;

  if (!_ && (typeof require !== "undefined" && require !== null)) {
    _ = require('underscore');
  }

  InvalidBindingError = (function(_super) {

    __extends(InvalidBindingError, _super);

    function InvalidBindingError(event, handler) {
      this.name = "InvalidBindingError";
      this.message = "Unable create binding for `" + event + "` due unimplemented handler: `#" + handler + "`";
    }

    return InvalidBindingError;

  })(Error);

  capitalize = function(string) {
    if (!string) {
      return "";
    }
    return string.charAt(0).toUpperCase() + string.slice(1);
  };

  deprecatedBackbone = (typeof Backbone !== "undefined" && Backbone !== null) && parseFloat(Backbone.VERSION) < 0.9;

  eventSplitter = /\s+/;

  createListener = function(target, events, callback, context) {
    var event, _i, _j, _len, _len1, _ref, _ref1, _results, _results1;
    if (target.addListener) {
      _ref = events.split(eventSplitter);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        event = _ref[_i];
        _results.push(target.addListener(event, callback));
      }
      return _results;
    } else if (deprecatedBackbone) {
      _ref1 = events.split(eventSplitter);
      _results1 = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        event = _ref1[_j];
        _results1.push(target.bind(event, callback, context));
      }
      return _results1;
    } else if (target.on) {
      return target.on(events, handler, context);
    } else {
      throw new TypeError("Expected an EventEmitter or Backbone.Events-compatible target.");
    }
  };

  destroyListener = function(target, events, callback) {
    var event, _i, _j, _len, _len1, _ref, _ref1, _results, _results1;
    if (target.removeListener) {
      _ref = events.split(eventSplitter);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        event = _ref[_i];
        _results.push(target.removeListener(event, callback));
      }
      return _results;
    } else if (deprecatedBackbone) {
      _ref1 = events.split(eventSplitter);
      _results1 = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        event = _ref1[_j];
        _results1.push(target.unbind(event, callback));
      }
      return _results1;
    } else if (target.off) {
      return target.off(events, handler);
    } else {
      throw new TypeError("Expected an EventEmitter or Backbone.Events-compatible target.");
    }
  };

  Observers = {
    _observedObjects: null,
    _observers: null,
    observe: function() {
      var context, event, events, handler, parsedEvents, target, targetEvents, _base, _name,
        _this = this;
      target = arguments[0], events = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      context = null;
      this._eventHandlerPrefix || (this._eventHandlerPrefix = 'on');
      if (events.length === 1) {
        if ((_(events[0])).isString()) {
          events = events[0].split(" ");
        }
        if ((_(events[0])).isObject()) {
          events = events[0];
        }
      } else if (_.isObject(_.last(events))) {
        context = events.pop();
      }
      if (_.isString(events[0])) {
        parsedEvents = {};
        _.each(events, function(e) {
          var action, handler, scope, _ref;
          _ref = e.split(':'), action = _ref[0], scope = _ref[1];
          handler = [_this._eventHandlerPrefix, capitalize(action), capitalize(scope)].join('');
          handler = _this[handler] || _this[e] || (function() {
            throw new InvalidBindingError(e, handler);
          })();
          return parsedEvents[e] = handler;
        });
        events = parsedEvents;
      }
      if (!_.isObject(events)) {
        throw new TypeError("Observe accepts either a String, an Array of Strings, or an Object.");
      }
      if (!target.cid) {
        target.cid = _.uniqueId('observed');
      }
      this._observedObjects = _.union((this._observedObjects || (this._observedObjects = [])), target);
      targetEvents = (_base = (this._observers || (this._observers = {})))[_name = target.cid] || (_base[_name] = {});
      for (event in events) {
        if (!__hasProp.call(events, event)) continue;
        handler = events[event];
        createListener(target, event, handler, context);
        (targetEvents[event] || (targetEvents[event] = [])).push(handler);
      }
      return true;
    },
    stopObserving: function(target) {
      var event, events, handler, handlers, index, _i, _j, _len, _len1, _ref;
      if (target == null) {
        target = false;
      }
      if (!(this._observedObjects && this._observers)) {
        return false;
      }
      if (!target) {
        _ref = this._observedObjects;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          target = _ref[_i];
          if (target) {
            this.stopObserving(target);
          }
        }
        return false;
      }
      events = this._observers[target.cid];
      for (event in events) {
        if (!__hasProp.call(events, event)) continue;
        handlers = events[event];
        for (index = _j = 0, _len1 = handlers.length; _j < _len1; index = ++_j) {
          handler = handlers[index];
          destroyListener(target, event, handler);
          delete [handlers][index];
        }
      }
      delete this._observedObjects[_.indexOf(this._observedObjects, target)];
      delete this._observers[target.cid];
      return true;
    },
    removeObserver: function(target, event, handlerToRemove) {
      var events, handler, handlers, index, _i, _j, _len, _len1, _ref;
      if (!target) {
        _ref = this._observedObjects;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          target = _ref[_i];
          this.removeObserver(target);
        }
      }
      events = _observers[target.cid];
      for (event in events) {
        if (!__hasProp.call(events, event)) continue;
        handlers = events[event];
        for (index = _j = 0, _len1 = handlers.length; _j < _len1; index = ++_j) {
          handler = handlers[index];
          if (handlerToRemove && handler !== handlerToRemove) {
            continue;
          }
          target.off(event, handler);
          events[event][index] = null;
          delete events[event][index];
        }
      }
      return true;
    }
  };

  exports = (typeof module !== "undefined" && module !== null ? module.exports : void 0) || this;

  exports.Observers = Observers;

}).call(this);
